{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs16   1  \cb3\cf16 #ifndef QUEUE_H_INCLUDED
\par \cb1\cf0\ul0\i0\b0   2  \cb3\cf16 #define QUEUE_H_INCLUDED
\par \cb1\cf0\ul0\i0\b0   3  
\par \cb1\cf0\ul0\i0\b0   4  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0   5  \cb3\cf14\b class \b0\cb1\cf0 Queue\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0   6    \cb3\cf14\b private\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0   7      \cb3\cf14\b class \b0\cb1\cf0 Node\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0   8          \cb3\cf14\b private\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0   9            \cb1\cf0 T\cb3\cf25 * \cb1\cf0 dataPtr\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  10            \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 prev\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  11            \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 next\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  12  
\par \cb1\cf0\ul0\i0\b0  13          \cb3\cf14\b public\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0  14            \cb3\cf14\b class \b0\cb1\cf0 Exception \cb3\cf25 : \cb3\cf14\b public \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b exception\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0  15              \cb3\cf14\b private\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0  16                \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 msg\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  17  
\par \cb1\cf0\ul0\i0\b0  18              \cb3\cf14\b public\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0  19                \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const char\b0\cb3\cf25 * \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par \cb1\cf0\ul0\i0\b0  20  
\par \cb1\cf0\ul0\i0\b0  21                \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 & \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par \cb1\cf0\ul0\i0\b0  22  
\par \cb1\cf0\ul0\i0\b0  23                \cb3\cf14\b virtual \b0\cb3\cf25 ~\cb1\cf0 Exception\cb3\cf25 () \cb3\cf14\b throw\b0\cb3\cf25 ()\{\}
\par \cb1\cf0\ul0\i0\b0  24  
\par \cb1\cf0\ul0\i0\b0  25                \cb3\cf14\b virtual const char\b0\cb3\cf25 * \cb1\cf0 what\cb3\cf25 () \cb3\cf14\b const throw\b0\cb3\cf25 () \{
\par \cb1\cf0\ul0\i0\b0  26                      \cb3\cf14\b return \b0\cb1\cf0 msg\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  27                \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0  28            \cb3\cf25 \};
\par \cb1\cf0\ul0\i0\b0  29  
\par \cb1\cf0\ul0\i0\b0  30          \cb1\cf0 Node\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  31          \cb1\cf0 Node\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &);
\par \cb1\cf0\ul0\i0\b0  32  
\par \cb1\cf0\ul0\i0\b0  33          \cb3\cf25 ~\cb1\cf0 Node\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  34  
\par \cb1\cf0\ul0\i0\b0  35          \cb1\cf0 T\cb3\cf25 * \cb1\cf0 getDataPtr\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  36          \cb1\cf0 T getData\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  37          \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getPrev\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  38          \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getNext\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  39  
\par \cb1\cf0\ul0\i0\b0  40          \cb3\cf14\b void \b0\cb1\cf0 setDataPtr\cb3\cf25 (\cb1\cf0 T\cb3\cf25 *);
\par \cb1\cf0\ul0\i0\b0  41          \cb3\cf14\b void \b0\cb1\cf0 setData\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &);
\par \cb1\cf0\ul0\i0\b0  42          \cb3\cf14\b void \b0\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *);
\par \cb1\cf0\ul0\i0\b0  43          \cb3\cf14\b void \b0\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *);
\par \cb1\cf0\ul0\i0\b0  44      \cb3\cf25 \};
\par \cb1\cf0\ul0\i0\b0  45  
\par \cb1\cf0\ul0\i0\b0  46      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 header\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  47  
\par \cb1\cf0\ul0\i0\b0  48      \cb3\cf14\b void \b0\cb1\cf0 copyAll\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >&);
\par \cb1\cf0\ul0\i0\b0  49  
\par \cb1\cf0\ul0\i0\b0  50      \cb3\cf14\b void \b0\cb1\cf0 deleteAll\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  51  
\par \cb1\cf0\ul0\i0\b0  52    \cb3\cf14\b public\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0  53      \cb3\cf14\b class \b0\cb1\cf0 Exception \cb3\cf25 : \cb3\cf14\b public \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b exception\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0  54        \cb3\cf14\b private\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0  55          \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 msg\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  56  
\par \cb1\cf0\ul0\i0\b0  57        \cb3\cf14\b public\b0\cb3\cf25 :
\par \cb1\cf0\ul0\i0\b0  58          \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const char\b0\cb3\cf25 * \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par \cb1\cf0\ul0\i0\b0  59  
\par \cb1\cf0\ul0\i0\b0  60          \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 & \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par \cb1\cf0\ul0\i0\b0  61  
\par \cb1\cf0\ul0\i0\b0  62          \cb3\cf14\b virtual \b0\cb3\cf25 ~\cb1\cf0 Exception\cb3\cf25 () \cb3\cf14\b throw\b0\cb3\cf25 ()\{\}
\par \cb1\cf0\ul0\i0\b0  63  
\par \cb1\cf0\ul0\i0\b0  64          \cb3\cf14\b virtual const char\b0\cb3\cf25 * \cb1\cf0 what\cb3\cf25 () \cb3\cf14\b const throw\b0\cb3\cf25 () \{
\par \cb1\cf0\ul0\i0\b0  65              \cb3\cf14\b return \b0\cb1\cf0 msg\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  66          \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0  67      \cb3\cf25 \};
\par \cb1\cf0\ul0\i0\b0  68  
\par \cb1\cf0\ul0\i0\b0  69      \cb1\cf0 Queue\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  70      \cb1\cf0 Queue\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Queue\cb3\cf25 &);
\par \cb1\cf0\ul0\i0\b0  71  
\par \cb1\cf0\ul0\i0\b0  72      \cb3\cf25 ~\cb1\cf0 Queue\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  73  
\par \cb1\cf0\ul0\i0\b0  74      \cb3\cf14\b bool \b0\cb1\cf0 isEmpty\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  75  
\par \cb1\cf0\ul0\i0\b0  76      \cb3\cf14\b void \b0\cb1\cf0 enqueue\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &);
\par \cb1\cf0\ul0\i0\b0  77  
\par \cb1\cf0\ul0\i0\b0  78      \cb1\cf0 T dequeue\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0  79  
\par \cb1\cf0\ul0\i0\b0  80      \cb1\cf0 T getFront\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  81  
\par \cb1\cf0\ul0\i0\b0  82      \cb1\cf0 Queue\cb3\cf25 & \cb3\cf14\b operator \b0\cb3\cf25 = (\cb3\cf14\b const \b0\cb1\cf0 Queue\cb3\cf25 &);
\par \cb1\cf0\ul0\i0\b0  83  \cb3\cf25 \};
\par \cb1\cf0\ul0\i0\b0  84  
\par \cb1\cf0\ul0\i0\b0  85  \cb3\cf6\b /// Node
\par \cb1\cf0\ul0\i0\b0  86  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0  87  \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Node\cb3\cf25 () : \cb1\cf0 dataPtr\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 ), \cb1\cf0 prev\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 ), \cb1\cf0 next\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 )\{\}
\par \cb1\cf0\ul0\i0\b0  88  
\par \cb1\cf0\ul0\i0\b0  89  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0  90  \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Node\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 ) : \cb1\cf0 dataPtr\cb3\cf25 (\cb3\cf14\b new \b0\cb1\cf0 T\cb3\cf25 (\cb1\cf0 e\cb3\cf25 )), \cb1\cf0 prev\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 ), \cb1\cf0 next\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0  91      \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 dataPtr \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0  92          \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria insuficiente, creando nodo"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0  93      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0  94  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0  95  
\par \cb1\cf0\ul0\i0\b0  96  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0  97  \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::~\cb1\cf0 Node\cb3\cf25 ()\{
\par \cb1\cf0\ul0\i0\b0  98      \cb3\cf14\b delete \b0\cb1\cf0 dataPtr\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0  99  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 100  
\par \cb1\cf0\ul0\i0\b0 101  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 102  \cb1\cf0 T\cb3\cf25 * \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getDataPtr\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 103      \cb3\cf14\b return \b0\cb1\cf0 dataPtr\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 104  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 105  
\par \cb1\cf0\ul0\i0\b0 106  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 107  \cb1\cf0 T Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getData\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 108      \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 dataPtr \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 109          \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Dato inexistente, getData"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 110      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 111  
\par \cb1\cf0\ul0\i0\b0 112      \cb3\cf14\b return \b0\cb3\cf25 *\cb1\cf0 dataPtr\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 113  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 114  
\par \cb1\cf0\ul0\i0\b0 115  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 116  \cb3\cf14\b typename \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getPrev\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 117      \cb3\cf14\b return \b0\cb1\cf0 prev\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 118  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 119  
\par \cb1\cf0\ul0\i0\b0 120  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 121  \cb3\cf14\b typename \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getNext\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 122      \cb3\cf14\b return \b0\cb1\cf0 next\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 123  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 124  
\par \cb1\cf0\ul0\i0\b0 125  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 126  \cb3\cf14\b void \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setDataPtr\cb3\cf25 (\cb1\cf0 T\cb3\cf25 * \cb1\cf0 p\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 127      \cb1\cf0 dataPtr \cb3\cf25 = \cb1\cf0 p\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 128  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 129  
\par \cb1\cf0\ul0\i0\b0 130  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 131  \cb3\cf14\b void \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setData\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 132      \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 dataPtr \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 133          \cb3\cf14\b if\b0\cb3\cf25 ((\cb1\cf0 dataPtr \cb3\cf25 = \cb3\cf14\b new \b0\cb1\cf0 T\cb3\cf25 (\cb1\cf0 e\cb3\cf25 )) == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 134              \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no disponible, setData"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 135          \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 136      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 137      \cb3\cf14\b else\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 138          \cb3\cf25 *\cb1\cf0 dataPtr \cb3\cf25 = \cb1\cf0 e\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 139      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 140  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 141  
\par \cb1\cf0\ul0\i0\b0 142  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 143  \cb3\cf14\b void \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 144      \cb1\cf0 prev \cb3\cf25 = \cb1\cf0 p\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 145  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 146  
\par \cb1\cf0\ul0\i0\b0 147  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 148  \cb3\cf14\b void \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 149      \cb1\cf0 next \cb3\cf25 = \cb1\cf0 p\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 150  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 151  
\par \cb1\cf0\ul0\i0\b0 152  \cb3\cf6\b /// Queue
\par \cb1\cf0\ul0\i0\b0 153  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 154  \cb3\cf14\b void \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 copyAll\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >& \cb1\cf0 l\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 155      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 (\cb1\cf0 l\cb3\cf25 .\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 156      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 newNode\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 157  
\par \cb1\cf0\ul0\i0\b0 158      \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 != \cb1\cf0 l\cb3\cf25 .\cb1\cf0 header\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 159          \cb3\cf14\b try\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 160              \cb3\cf14\b if\b0\cb3\cf25 ((\cb1\cf0 newNode \cb3\cf25 = \cb3\cf14\b new \b0\cb1\cf0 Node\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 ())) == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 161                  \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no disponible, copyAll"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 162              \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 163          \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 164          \cb3\cf14\b catch\b0\cb3\cf25 (\cb3\cf14\b typename \b0\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Exception ex\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 165              \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb1\cf0 ex\cb3\cf25 .\cb1\cf0 what\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 166          \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 167  
\par \cb1\cf0\ul0\i0\b0 168          \cb1\cf0 newNode\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 169          \cb1\cf0 newNode\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 170  
\par \cb1\cf0\ul0\i0\b0 171          \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ()->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 newNode\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 172          \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 newNode\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 173  
\par \cb1\cf0\ul0\i0\b0 174          \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0 175      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 176  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 177  
\par \cb1\cf0\ul0\i0\b0 178  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 179  \cb3\cf14\b void \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 deleteAll\cb3\cf25 ()\{
\par \cb1\cf0\ul0\i0\b0 180      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 181  
\par \cb1\cf0\ul0\i0\b0 182      \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 () != \cb1\cf0 header\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 183          \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0 184  
\par \cb1\cf0\ul0\i0\b0 185          \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 186  
\par \cb1\cf0\ul0\i0\b0 187          \cb3\cf14\b delete \b0\cb1\cf0 aux\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 188      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 189  
\par \cb1\cf0\ul0\i0\b0 190      \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 191  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 192  
\par \cb1\cf0\ul0\i0\b0 193  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 194  \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Queue\cb3\cf25 () : \cb1\cf0 header\cb3\cf25 (\cb3\cf14\b new \b0\cb1\cf0 Node\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 195      \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 header \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 196          \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no disponible, inicializando Queue"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 197      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 198  
\par \cb1\cf0\ul0\i0\b0 199      \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 200      \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 201  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 202  
\par \cb1\cf0\ul0\i0\b0 203  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 204  \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Queue\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Queue\cb3\cf25 & \cb1\cf0 q\cb3\cf25 ) : \cb1\cf0 Queue\cb3\cf25 ()\{
\par \cb1\cf0\ul0\i0\b0 205      \cb1\cf0 copyAll\cb3\cf25 (\cb1\cf0 q\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 206  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 207  
\par \cb1\cf0\ul0\i0\b0 208  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 209  \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::~\cb1\cf0 Queue\cb3\cf25 ()\{
\par \cb1\cf0\ul0\i0\b0 210      \cb1\cf0 deleteAll\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0 211  
\par \cb1\cf0\ul0\i0\b0 212      \cb3\cf14\b delete \b0\cb1\cf0 header\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 213  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 214  
\par \cb1\cf0\ul0\i0\b0 215  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 216  \cb3\cf14\b bool \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 isEmpty\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 217      \cb3\cf14\b return \b0\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 () == \cb1\cf0 header\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 218  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 219  
\par \cb1\cf0\ul0\i0\b0 220  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 221  \cb3\cf14\b void \b0\cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 enqueue\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 222      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 223  
\par \cb1\cf0\ul0\i0\b0 224      \cb3\cf14\b try\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 225          \cb3\cf14\b if\b0\cb3\cf25 ((\cb1\cf0 aux \cb3\cf25 = \cb3\cf14\b new \b0\cb1\cf0 Node\cb3\cf25 (\cb1\cf0 e\cb3\cf25 )) == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 226              \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no suficiente, enqueue"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 227          \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 228      \cb3\cf25 \}\cb3\cf14\b catch\b0\cb3\cf25 (\cb3\cf14\b typename \b0\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Exception ex\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 229          \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb1\cf0 ex\cb3\cf25 .\cb1\cf0 what\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 230      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 231  
\par \cb1\cf0\ul0\i0\b0 232      \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 233      \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 234  
\par \cb1\cf0\ul0\i0\b0 235      \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ()->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 236      \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 237  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 238  
\par \cb1\cf0\ul0\i0\b0 239  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 240  \cb1\cf0 T Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 dequeue\cb3\cf25 ()\{
\par \cb1\cf0\ul0\i0\b0 241      \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 isEmpty\cb3\cf25 ())\{
\par \cb1\cf0\ul0\i0\b0 242          \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Insuficiencia de datos, dequeue"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 243      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 244  
\par \cb1\cf0\ul0\i0\b0 245      \cb1\cf0 T result\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ()->\cb1\cf0 getData\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 246  
\par \cb1\cf0\ul0\i0\b0 247      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 248  
\par \cb1\cf0\ul0\i0\b0 249      \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ()->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 250      \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ()->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ());
\par \cb1\cf0\ul0\i0\b0 251  
\par \cb1\cf0\ul0\i0\b0 252      \cb3\cf14\b delete \b0\cb1\cf0 aux\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 253  
\par \cb1\cf0\ul0\i0\b0 254      \cb3\cf14\b return \b0\cb1\cf0 result\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 255  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 256  
\par \cb1\cf0\ul0\i0\b0 257  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 258  \cb1\cf0 T Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 getFront\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 \{
\par \cb1\cf0\ul0\i0\b0 259      \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 isEmpty\cb3\cf25 ())\{
\par \cb1\cf0\ul0\i0\b0 260          \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Insuficiencia de datos, getFront"\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 261      \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 262  
\par \cb1\cf0\ul0\i0\b0 263      \cb3\cf14\b return \b0\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ()->\cb1\cf0 getData\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0 264  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 265  
\par \cb1\cf0\ul0\i0\b0 266  \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0\ul0\i0\b0 267  \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >& \cb1\cf0 Queue\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb3\cf14\b operator \b0\cb3\cf25 = (\cb3\cf14\b const \b0\cb1\cf0 Queue\cb3\cf25 & \cb1\cf0 q\cb3\cf25 )\{
\par \cb1\cf0\ul0\i0\b0 268      \cb1\cf0 deleteAll\cb3\cf25 ();
\par \cb1\cf0\ul0\i0\b0 269  
\par \cb1\cf0\ul0\i0\b0 270      \cb1\cf0 copyAll\cb3\cf25 (\cb1\cf0 q\cb3\cf25 );
\par \cb1\cf0\ul0\i0\b0 271  
\par \cb1\cf0\ul0\i0\b0 272      \cb3\cf14\b return \b0\cb3\cf25 *\cb3\cf14\b this\b0\cb3\cf25 ;
\par \cb1\cf0\ul0\i0\b0 273  \cb3\cf25 \}
\par \cb1\cf0\ul0\i0\b0 274  
\par \cb1\cf0\ul0\i0\b0 275  \cb3\cf16 #endif \cb3\cf4 // QUEUE_H_INCLUDED
\par }